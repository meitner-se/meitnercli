package locale

import (
	"context"
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/friendsofgo/errors"
	"github.com/meitner-se/meitnercli/locale/parser"
)

type Config struct {
	DefinitionInputFile    string
	DefinitionOutputFileGO string

	ValuesInputFile    string
	ValuesOutputFileGO string
	ValuesOutputFileTS string

	AuthPKG string
}

func Generate(ctx context.Context, config Config) error {
	definitions, err := parser.ParseDefinitions(ctx, config.DefinitionInputFile)
	if err != nil {
		return err
	}

	values, err := parser.ParseValues(ctx, definitions, config.ValuesInputFile)
	if err != nil {
		return err
	}

	if err := generateDefinitionsGO(definitions, config.DefinitionOutputFileGO); err != nil {
		return err
	}

	if err := generateValuesGO(values, config.ValuesOutputFileGO, config.AuthPKG); err != nil {
		return err
	}

	if err := generateValuesTS(values, config.ValuesOutputFileTS); err != nil {
		return err
	}

	return nil
}

func generateDefinitionsGO(definitions []*parser.Definition, outputFile string) error {
	out, err := os.Create(outputFile)
	if err != nil {
		return errors.Wrap(err, "cannot create output file")
	}

	defer out.Close()

	if _, err := fmt.Fprint(out, "package locale\n\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	for _, def := range definitions {
		if _, err := fmt.Fprintf(out, "type %s struct {\n", def.Name); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		for _, field := range def.Fields {
			if _, err := fmt.Fprintf(out, "\t%s %s %s\n", field.Name, field.Typ, field.Tag); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}
		}

		if _, err := fmt.Fprint(out, "}\n\n"); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}
	}

	return nil
}

func generateValuesTS(values *parser.Object, outputFile string) error {
	out, err := os.Create(outputFile)
	if err != nil {
		return errors.Wrap(err, "cannot create output file")
	}

	defer out.Close()

	if _, err := fmt.Fprint(out, "// Code generated by meitnercli; DO NOT EDIT.\n\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if err := generateValueOptions(out, "", values.Fields); err != nil {
		return err
	}

	if _, err := fmt.Fprint(out, "const Translations = {\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if err := generateTranslations(out, "\t", "", values.Fields); err != nil {
		return errors.Wrap(err, "cannot generate translations")
	}

	if _, err := fmt.Fprint(out, "}\n\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if _, err := fmt.Fprint(out, "export default Translations;"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	return nil
}

func generateTranslations(out io.Writer, tabs, prefix string, fields []parser.ObjectField) error {
	for _, field := range fields {
		_, err := fmt.Fprintf(out, "%s%s: ", tabs, field.Name)
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		if field.Object != nil {
			_, err := fmt.Fprintf(out, "{\n")
			if err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}

			err = generateTranslations(out, tabs+"\t", prefix+field.Name, field.Object.Fields)
			if err != nil {
				return err
			}

			_, err = fmt.Fprintf(out, "%s},\n", tabs)
			if err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}

			continue
		}

		params := field.ObjectFieldValue.Params()

		if len(params) == 0 {
			fmt.Fprintf(out, "{ key: \"%s\" },\n", field.TagNested)
			continue
		}

		fieldOptions := fmt.Sprintf("%s%sOptions", prefix, field.Name)

		_, err = fmt.Fprintf(out, "({ %s }: %s) => ({ key: \"%s\", values: { %s } }),\n", strings.Join(params, ", "), fieldOptions, field.TagNested, strings.Join(params, ", "))
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}
	}

	return nil
}

func generateValueOptions(out io.Writer, prefix string, fields []parser.ObjectField) error {
	for _, field := range fields {
		fieldName := fmt.Sprintf("%s%s", prefix, field.Name)

		if field.Object != nil {
			if err := generateValueOptions(out, fieldName, field.Object.Fields); err != nil {
				return err
			}

			continue
		}

		params := field.ObjectFieldValue.Params()

		if len(params) == 0 {
			continue
		}

		_, err := fmt.Fprintf(out, "type %sOptions = {\n", fieldName)
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		for _, param := range params {
			_, err := fmt.Fprintf(out, "\t%s: string;\n", param)
			if err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}
		}

		_, err = fmt.Fprintf(out, "}\n\n")
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}
	}

	return nil
}

func generateValuesGO(values *parser.Object, outputFile, pkgAuth string) error {
	out, err := os.Create(outputFile)
	if err != nil {
		return errors.Wrap(err, "cannot create output file")
	}

	defer out.Close()

	if _, err := fmt.Fprintf(out, "// Code generated by meitnercli; DO NOT EDIT.\n\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if _, err := fmt.Fprint(out, "package locale\n\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if _, err := fmt.Fprint(out, "import (\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if _, err := fmt.Fprint(out, "\t\"context\"\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if _, err := fmt.Fprint(out, "\t\"strings\"\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if _, err := fmt.Fprintf(out, "\n\t\"%s\"\n", pkgAuth); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if _, err := fmt.Fprint(out, ")\n\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	// Generate bases for all languages.
	languages := []string{
		parser.English,
		parser.Swedish,
	}

	for _, lang := range languages {
		if _, err := fmt.Fprintf(out, "var %s = %s{\n", lang, parser.Locale); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		if err := generateValuesToFile(out, "\t", values.Fields, lang); err != nil {
			return err
		}

		if _, err := fmt.Fprint(out, "}\n\n"); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		// Generate school type locales for the language.
		schoolTypes := []string{
			parser.Preschool,
			parser.Elementary,
			parser.UpperSecondary,
		}

		for _, schoolType := range schoolTypes {
			if _, err := fmt.Fprintf(out, "var %s%s = %s%s(%s)\n", lang, schoolType, strings.ToLower(lang), schoolType, lang); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}
		}

		if _, err := fmt.Fprint(out, "\n"); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		for _, schoolType := range schoolTypes {
			if _, err := fmt.Fprintf(out, "func %s%s(%s %s) %s {\n", strings.ToLower(lang), schoolType, strings.ToLower(lang), parser.Locale, parser.Locale); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}

			if err := generateValuesToSchoolTypeFunc(out, "\t"+strings.ToLower(lang), values.Fields, lang, schoolType); err != nil {
				return err
			}

			if _, err := fmt.Fprintf(out, "\treturn %s\n", strings.ToLower(lang)); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}

			if _, err := fmt.Fprint(out, "}\n\n"); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}
		}
	}

	for _, lang := range languages {
		langFromClaims := fmt.Sprintf(`
func %sFromClaims(claims *authentication.Claims) Locale {
	if claims == nil {
		return %s
	}

	if claims.Organization == nil {
		return %s
	}

	switch {
		case claims.Organization.TypeOfSchooling.Is%s():
			return %s%s
		case claims.Organization.TypeOfSchooling.Is%s():
			return %s%s
		case claims.Organization.TypeOfSchooling.Is%s():
			return %s%s
		default:
			return %s
	}
}
`,
			lang,
			lang,
			lang,
			parser.Elementary, lang, parser.Elementary,
			parser.UpperSecondary, lang, parser.UpperSecondary,
			parser.Preschool, lang, parser.Preschool,
			lang,
		)

		if _, err := fmt.Fprint(out, langFromClaims); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}
	}

	localeFromClaims := fmt.Sprintf(`
// FromClaims returns the locale from Claims but uses the Swedish as default, if no claims are provided.
// TODO : FIX to use english as well
func FromClaims(claims *authentication.Claims) Locale {
	return SwedishFromClaims(claims)
}
`)

	if _, err := fmt.Fprint(out, localeFromClaims); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if err := generateValuesToFormatFunc(out, "", values.Fields); err != nil {
		return err
	}

	return nil
}

func generateValuesToSchoolTypeFunc(out io.Writer, prefix string, fields []parser.ObjectField, lang, schoolType string) error {
	for _, field := range fields {
		if field.Object != nil {
			newPrefix := fmt.Sprintf("%s.%s", prefix, field.Name)

			if err := generateValuesToSchoolTypeFunc(out, newPrefix, field.Object.Fields, lang, schoolType); err != nil {
				return err
			}

			continue
		}

		var fieldValue parser.ObjectFieldValueSchoolType

		switch schoolType {
		case parser.Preschool:
			if field.ObjectFieldValue.Preschool == nil {
				continue
			}

			fieldValue = *field.ObjectFieldValue.Preschool

		case parser.Elementary:
			if field.ObjectFieldValue.Elementary == nil {
				continue
			}

			fieldValue = *field.ObjectFieldValue.Elementary

		case parser.UpperSecondary:
			if field.ObjectFieldValue.UpperSecondary == nil {
				continue
			}

			fieldValue = *field.ObjectFieldValue.UpperSecondary

		default:
			panic("unexpected type")
		}

		var value string

		switch lang {
		case parser.English:
			value = fieldValue.English
		case parser.Swedish:
			value = fieldValue.Swedish
		default:
			panic("unexpected type")
		}

		if _, err := fmt.Fprintf(out, "%s.%s = %s\n", prefix, field.Name, value); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}
	}

	return nil
}

func generateValuesToFile(out io.Writer, tabsStr string, fields []parser.ObjectField, lang string) error {
	for _, field := range fields {
		if _, err := fmt.Fprintf(out, "%s%s: ", tabsStr, field.Name); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		switch {
		case field.Object != nil:
			if _, err := fmt.Fprintf(out, "%s{\n", field.Object.Name); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}

			if err := generateValuesToFile(out, tabsStr+"\t", field.Object.Fields, lang); err != nil {
				return err
			}

			if _, err := fmt.Fprintf(out, "%s},\n", tabsStr); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}

		case field.ObjectFieldValue != nil:
			var value string

			switch lang {
			case parser.English:
				value = field.ObjectFieldValue.English
			case parser.Swedish:
				value = field.ObjectFieldValue.Swedish
			}

			if _, err := fmt.Fprintf(out, "%s,\n", value); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}

		default:
			panic("unexpected type")
		}
	}

	return nil
}

func generateValuesToFormatFunc(out io.Writer, prefix string, fields []parser.ObjectField) error {
	prefixWithoutDots := strings.ReplaceAll(prefix, ".", "")

	for _, field := range fields {
		fieldToReplace := field.Name

		if prefix != "" {
			fieldToReplace = prefix + "." + field.Name
		}

		if field.Object != nil {
			if err := generateValuesToFormatFunc(out, fieldToReplace, field.Object.Fields); err != nil {
				return err
			}

			continue
		}

		if field.ObjectFieldValue == nil {
			return errors.New("unexpected type")
		}

		params := field.ObjectFieldValue.Params()

		if len(params) == 0 {
			continue
		}

		_, err := fmt.Fprintf(out, "\nfunc %s%s(ctx context.Context, %s string) string {\n", prefixWithoutDots, field.Name, strings.Join(params, ", "))
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		_, err = fmt.Fprint(out, "\tl := FromClaims(authentication.ClaimsFromContext(ctx))\n")
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		_, err = fmt.Fprint(out, "\treturn strings.NewReplacer(\n")
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		for _, param := range params {
			_, err = fmt.Fprintf(out, "\t\t\"{{%s}}\", %s,\n", param, param)
			if err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}
		}

		_, err = fmt.Fprintf(out, "\t).Replace(l.%s)\n", fieldToReplace)
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		_, err = fmt.Fprint(out, "}\n")
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}
	}

	return nil
}
