package locale

import (
	"context"
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/friendsofgo/errors"
	"github.com/meitner-se/meitnercli/locale/parser"
)

type Config struct {
	DefinitionInputFile    string
	DefinitionOutputFileGO string

	ValuesInputFile    string
	ValuesOutputFileGO string
	ValuesOutputFileTS string

	OrganizationModelPKG string
}

func Generate(ctx context.Context, config Config) error {
	definitions, err := parser.ParseDefinitions(ctx, config.DefinitionInputFile)
	if err != nil {
		return err
	}

	values, err := parser.ParseValues(ctx, definitions, config.ValuesInputFile)
	if err != nil {
		return err
	}

	if err := generateDefinitionsGO(definitions, config.DefinitionOutputFileGO); err != nil {
		return err
	}

	if err := generateValuesGO(values, config.ValuesOutputFileGO, config.OrganizationModelPKG); err != nil {
		return err
	}

	if err := generateValuesTS(values, config.ValuesOutputFileTS); err != nil {
		return err
	}

	return nil
}

func generateDefinitionsGO(definitions []*parser.Definition, outputFile string) error {
	out, err := os.Create(outputFile)
	if err != nil {
		return errors.Wrap(err, "cannot create output file")
	}

	defer out.Close()

	if _, err := fmt.Fprint(out, "package locale\n\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	for _, def := range definitions {
		if _, err := fmt.Fprintf(out, "type %s struct {\n", def.Name); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		for _, field := range def.Fields {
			if _, err := fmt.Fprintf(out, "\t%s %s %s\n", field.Name, field.Typ, field.Tag); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}
		}

		if _, err := fmt.Fprint(out, "}\n\n"); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}
	}

	return nil
}

func generateValuesTS(values *parser.Object, outputFile string) error {
	out, err := os.Create(outputFile)
	if err != nil {
		return errors.Wrap(err, "cannot create output file")
	}

	defer out.Close()

	if _, err := fmt.Fprint(out, "// Code generated by meitnercli; DO NOT EDIT.\n\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if err := generateValueOptions(out, "", values.Fields); err != nil {
		return err
	}

	if _, err := fmt.Fprint(out, "const Translations = {\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if err := generateTranslations(out, "\t", "", values.Fields); err != nil {
		return errors.Wrap(err, "cannot generate translations")
	}

	if _, err := fmt.Fprint(out, "}\n\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if _, err := fmt.Fprint(out, "export default Translations;"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	return nil
}

func generateTranslations(out io.Writer, tabs, prefix string, fields []parser.ObjectField) error {
	for _, field := range fields {
		_, err := fmt.Fprintf(out, "%s%s: ", tabs, field.Name)
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		if field.Object != nil {
			_, err := fmt.Fprintf(out, "{\n")
			if err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}

			err = generateTranslations(out, tabs+"\t", prefix+field.Name, field.Object.Fields)
			if err != nil {
				return err
			}

			_, err = fmt.Fprintf(out, "%s},\n", tabs)
			if err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}

			continue
		}

		params := field.ObjectFieldValue.Params()

		if len(params) == 0 {
			fmt.Fprintf(out, "{ key: \"%s\" },\n", field.TagNested)
			continue
		}

		fieldOptions := fmt.Sprintf("%s%sOptions", prefix, field.Name)

		_, err = fmt.Fprintf(out, "({ %s }: %s) => ({ key: \"%s\", values: { %s } }),\n", strings.Join(params, ", "), fieldOptions, field.TagNested, strings.Join(params, ", "))
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}
	}

	return nil
}

func generateValueOptions(out io.Writer, prefix string, fields []parser.ObjectField) error {
	for _, field := range fields {
		fieldName := fmt.Sprintf("%s%s", prefix, field.Name)

		if field.Object != nil {
			if err := generateValueOptions(out, fieldName, field.Object.Fields); err != nil {
				return err
			}

			continue
		}

		params := field.ObjectFieldValue.Params()

		if len(params) == 0 {
			continue
		}

		_, err := fmt.Fprintf(out, "type %sOptions = {\n", fieldName)
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		for _, param := range params {
			_, err := fmt.Fprintf(out, "\t%s: string;\n", param)
			if err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}
		}

		_, err = fmt.Fprintf(out, "}\n\n")
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}
	}

	return nil
}

func generateValuesGO(values *parser.Object, outputFile, pkgOrganizationModel string) error {
	out, err := os.Create(outputFile)
	if err != nil {
		return errors.Wrap(err, "cannot create output file")
	}

	defer out.Close()

	if _, err := fmt.Fprintf(out, "// Code generated by meitnercli; DO NOT EDIT.\n\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if _, err := fmt.Fprint(out, "package locale\n\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if _, err := fmt.Fprint(out, "import (\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if _, err := fmt.Fprint(out, "\t\"strings\"\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if _, err := fmt.Fprintf(out, "\n\torganizationModel \"%s\"\n", pkgOrganizationModel); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if _, err := fmt.Fprint(out, ")\n\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	// Generate bases for all languages.
	languages := []string{
		parser.English,
		parser.Swedish,
	}

	if _, err := fmt.Fprintf(out, "const (\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	// Write the languages as constants.
	// need to be consistent naming as the language set on users
	for _, lang := range languages {
		var langCode string

		switch lang {
		case parser.English:
			langCode = "en"
		case parser.Swedish:
			langCode = "sv"
		}

		if _, err := fmt.Fprintf(out, "\tLang%s string = \"%s\"\n", lang, langCode); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}
	}

	if _, err := fmt.Fprintf(out, ")\n\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	for _, lang := range languages {
		if _, err := fmt.Fprintf(out, "var %s = %s{\n", lang, parser.Locale); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		if err := generateValuesToFile(out, "\t", values.Fields, lang); err != nil {
			return err
		}

		if _, err := fmt.Fprint(out, "}\n\n"); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		// Generate school type locales for the language.
		schoolTypes := []string{
			parser.Preschool,
			parser.Elementary,
			parser.UpperSecondary,
		}

		for _, schoolType := range schoolTypes {
			if _, err := fmt.Fprintf(out, "var %s%s = %s%s(%s)\n", lang, schoolType, strings.ToLower(lang), schoolType, lang); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}
		}

		if _, err := fmt.Fprint(out, "\n"); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		for _, schoolType := range schoolTypes {
			if _, err := fmt.Fprintf(out, "func %s%s(%s %s) %s {\n", strings.ToLower(lang), schoolType, strings.ToLower(lang), parser.Locale, parser.Locale); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}

			if err := generateValuesToSchoolTypeFunc(out, "\t"+strings.ToLower(lang), values.Fields, lang, schoolType); err != nil {
				return err
			}

			if _, err := fmt.Fprintf(out, "\treturn %s\n", strings.ToLower(lang)); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}

			if _, err := fmt.Fprint(out, "}\n\n"); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}
		}
	}

	if _, err := fmt.Fprintf(out, `
type Options struct {
	Language 		string // Should be one to one for user languages
	TypeOfSchooling organizationModel.OrganizationTypeOfSchooling
}

`); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if _, err := fmt.Fprintf(out, "func FromOptions(options Options) Locale {\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	if _, err := fmt.Fprintf(out, "\tswitch options.Language {\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	for _, lang := range languages {
		if _, err := fmt.Fprintf(out, "\tcase Lang%s:\n\t\treturn %s\n", lang, lang); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}
	}

	if _, err := fmt.Fprintf(out, "\tdefault:\n\t\tpanic(\"invalid language\")\n\t}\n}\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	for _, lang := range languages {
		langFromTypeOfSchooling := fmt.Sprintf(`
func %sFromTypeOfSchooling(typeOfSchooling organizationModel.OrganizationTypeOfSchooling) Locale {
	switch {
	case typeOfSchooling.Is%s():
		return %s%s
	case typeOfSchooling.Is%s():
		return %s%s
	case typeOfSchooling.Is%s():
		return %s%s
	default:
		return %s
	}
}
`,
			lang,
			parser.Elementary, lang, parser.Elementary,
			parser.UpperSecondary, lang, parser.UpperSecondary,
			parser.Preschool, lang, parser.Preschool,
			lang,
		)

		if _, err := fmt.Fprint(out, langFromTypeOfSchooling); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}
	}

	if err := generateValuesFromNotificationsToFormatFunc(out, "", values.Fields); err != nil {
		return err
	}

	return nil
}

func generateValuesToSchoolTypeFunc(out io.Writer, prefix string, fields []parser.ObjectField, lang, schoolType string) error {
	for _, field := range fields {
		if field.Object != nil {
			newPrefix := fmt.Sprintf("%s.%s", prefix, field.Name)

			if err := generateValuesToSchoolTypeFunc(out, newPrefix, field.Object.Fields, lang, schoolType); err != nil {
				return err
			}

			continue
		}

		var fieldValue parser.ObjectFieldValueSchoolType

		switch schoolType {
		case parser.Preschool:
			if field.ObjectFieldValue.Preschool == nil {
				continue
			}

			fieldValue = *field.ObjectFieldValue.Preschool

		case parser.Elementary:
			if field.ObjectFieldValue.Elementary == nil {
				continue
			}

			fieldValue = *field.ObjectFieldValue.Elementary

		case parser.UpperSecondary:
			if field.ObjectFieldValue.UpperSecondary == nil {
				continue
			}

			fieldValue = *field.ObjectFieldValue.UpperSecondary

		default:
			panic("unexpected type")
		}

		var value string

		switch lang {
		case parser.English:
			value = fieldValue.English
		case parser.Swedish:
			value = fieldValue.Swedish
		default:
			panic("unexpected type")
		}

		if _, err := fmt.Fprintf(out, "%s.%s = %s\n", prefix, field.Name, value); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}
	}

	return nil
}

func generateValuesToFile(out io.Writer, tabsStr string, fields []parser.ObjectField, lang string) error {
	for _, field := range fields {
		if _, err := fmt.Fprintf(out, "%s%s: ", tabsStr, field.Name); err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		switch {
		case field.Object != nil:
			if _, err := fmt.Fprintf(out, "%s{\n", field.Object.Name); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}

			if err := generateValuesToFile(out, tabsStr+"\t", field.Object.Fields, lang); err != nil {
				return err
			}

			if _, err := fmt.Fprintf(out, "%s},\n", tabsStr); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}

		case field.ObjectFieldValue != nil:
			var value string

			switch lang {
			case parser.English:
				value = field.ObjectFieldValue.English
			case parser.Swedish:
				value = field.ObjectFieldValue.Swedish
			}

			if _, err := fmt.Fprintf(out, "%s,\n", value); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}

		default:
			panic("unexpected type")
		}
	}

	return nil
}

func generateValuesFromNotificationsToFormatFunc(out io.Writer, prefix string, fields []parser.ObjectField) error {
	var notificationsField *parser.ObjectField

	for i := range fields {
		if fields[i].Name == "Notifications" && fields[i].Object != nil {
			notificationsField = &fields[i]
			break
		}
	}

	if notificationsField == nil {
		return errors.New("Notifications-field not found")
	}

	if _, err := fmt.Fprintf(out, "type NotificationFunc func(options Options) string\n\n"); err != nil {
		return errors.Wrap(err, "cannot write to output file")
	}

	for _, notificationField := range notificationsField.Object.Fields {
		if notificationField.Object == nil || notificationField.Object.Name != "LocaleNotification" {
			return errors.New("notification field must be of type LocaleNotification")
		}

		for _, field := range notificationField.Object.Fields {
			funcName := fmt.Sprintf("%s%s", notificationField.Name, field.Name)

			params := field.ObjectFieldValue.Params()

			if len(params) == 0 {
				_, err := fmt.Fprintf(out, "\nfunc %s(options Options) string {\n", funcName)
				if err != nil {
					return errors.Wrap(err, "cannot write to output file")
				}
			} else {
				_, err := fmt.Fprintf(out, "\nfunc %s(%s string, options Options) string {\n", funcName, strings.Join(params, ", "))
				if err != nil {
					return errors.Wrap(err, "cannot write to output file")
				}
			}

			_, err := fmt.Fprint(out, "\tl := FromOptions(options)\n")
			if err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}

			if len(params) == 0 {
				_, err = fmt.Fprintf(out, "\treturn l.Notifications.%s.%s\n", notificationField.Name, field.Name)
				if err != nil {
					return errors.Wrap(err, "cannot write to output file")
				}
			} else {
				_, err = fmt.Fprint(out, "\treturn strings.NewReplacer(\n")
				if err != nil {
					return errors.Wrap(err, "cannot write to output file")
				}

				for _, param := range params {
					_, err = fmt.Fprintf(out, "\t\t\"{{%s}}\", %s,\n", param, param)
					if err != nil {
						return errors.Wrap(err, "cannot write to output file")
					}
				}

				_, err = fmt.Fprintf(out, "\t).Replace(l.Notifications.%s.%s)\n", notificationField.Name, field.Name)
				if err != nil {
					return errors.Wrap(err, "cannot write to output file")
				}
			}

			if _, err := fmt.Fprint(out, "}\n"); err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}
		}
	}

	return nil
}

func generateValuesToFormatFunc(out io.Writer, prefix string, fields []parser.ObjectField) error {
	prefixWithoutDots := strings.ReplaceAll(prefix, ".", "")

	for _, field := range fields {
		fieldToReplace := field.Name

		if prefix != "" {
			fieldToReplace = prefix + "." + field.Name
		}

		if field.Object != nil {
			if err := generateValuesToFormatFunc(out, fieldToReplace, field.Object.Fields); err != nil {
				return err
			}

			continue
		}

		if field.ObjectFieldValue == nil {
			return errors.New("unexpected type")
		}

		params := field.ObjectFieldValue.Params()

		if len(params) == 0 {
			continue
		}

		_, err := fmt.Fprintf(out, "\nfunc %s%s(%s string, options Options) string {\n", prefixWithoutDots, field.Name, strings.Join(params, ", "))
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		_, err = fmt.Fprint(out, "\tl := FromOptions(options)\n")
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		_, err = fmt.Fprint(out, "\treturn strings.NewReplacer(\n")
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		for _, param := range params {
			_, err = fmt.Fprintf(out, "\t\t\"{{%s}}\", %s,\n", param, param)
			if err != nil {
				return errors.Wrap(err, "cannot write to output file")
			}
		}

		_, err = fmt.Fprintf(out, "\t).Replace(l.%s)\n", fieldToReplace)
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}

		_, err = fmt.Fprint(out, "}\n")
		if err != nil {
			return errors.Wrap(err, "cannot write to output file")
		}
	}

	return nil
}
